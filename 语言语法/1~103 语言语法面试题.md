# 1、new、delete、malloc、free关系
delete会调用对象的析构函数,和malloc对应free只会释放内存；<br>
new调用构造函数。<br>
malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。<br>
它们都可用于申请动态内存和释放内存。<br>
对于非内部数据类型的对象而言，光用maloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理与释放内存工作的运算符delete。注意new/delete不是库函数。
```
参考回答：首先，new/delete是C++的关键字，而malloc/free是C语言的库函数，后者使用必须指明申请内存空间的大小，
对于类类型的对象，后者不会调用构造函数和析构函数
```
# 2、delete与 delete []区别
* delete只会调用一次析构函数，而delete[]会调用每一个成员的析构函数。
* 在MoreEffective C++中有更为详细的解释：“当delete操作符用于数组时，它为每个数组元素调用析构函数，然后调用operatordelete来释放内存。”，delete与New配套，delete[]与new []配套<br>
如下例：<br>
*=[10];*=;int*=[10];int*=;delete[];//-1-delete[];//-2-delete[];//-3-delete[];//-4-在-4-处报错。
这就说明：对于内建简单数据类型，delete和delete[]功能是相同的。对于自定义的复杂数据类型，delete和delete[]不能互用。delete[]删除一个数组，delete删除一个指针简单来说，用new分配的内存用delete删除用new[]分配的内存用delete[]删除delete[]会调用数组元素的析构函数。内部数据类型没有析构函数，所以问题不大。如果你在用delete时没用括号，delete就会认为指向的是单个对象，否则，它就会认为指向的是一个数组。

# 3、C和C++的共同点？不同之处？
* 设计思想上：C++是面向对象的语言，而C是面向过程的结构化编程语言 
* 语法上：
```
  *   <font size="2">C++具有封装、继承和多态三种特性</font>
```
   C++相比C，增加多许多类型安全的功能，比如强制类型转换、<br>
   C++支持范式编程，比如模板类、函数模板等<br>

# 4、继承的优缺点
优点：类继承是在编译时刻静态定义的，且可直接使用，类继承可以较方便地改变父类的实现。<br>
缺点：<br>
* 首先，因为继承在编译时刻就定义了，所以无法在运行时刻改变从父类继承的实现。
* 其次，父类通常至少定义了子类的部分行为，父类的任何改变都可能影响子类的行为。如果继承下来的实现不适合解决新的问题，则父类必须重写或被其他更适合的类替换。这种依赖关系限制了灵活性并最终限制了复用性。

# 5、C++有哪些性质（面向对象特点）
封装，继承和多态。<br>
在面向对象程序设计语言中，封装是利用可重用成分构造软件系统的特性，它不仅支持系统的可重用性，而且还有利于提高系统的可扩充性；消息传递可以实现发送一个通用的消息而调用不同的方法；封装是实现信息隐蔽的一种技术，其目的是使类的定义和实现分离。

# 6、子类析构时要调用父类的析构函数吗？
析构函数调用的次序是先派生类的析构后基类的析构，也就是说在基类的的析构调用的时候,派生类的信息已经全部销毁了定义一个对象时先调用基类的构造函数、然后调用派生类的构造函数；析构的时候恰好相反：先调用派生类的析构函数、然后调用基类的析构函数JAVA无析构函数深拷贝和浅拷贝

# 7、多态，虚函数，纯虚函数
* 多态：是对于不同对象接收相同消息时产生不同的动作。C++的多态性具体体现在运行和编译两个方面：在程序运行时的多态性通过继承和虚函数来体现；
在程序编译时多态性体现在函数和运算符的重载上
* 虚函数：在基类中冠以关键字 virtual 的成员函数。 它提供了一种接口界面。允许在派生类中对基类的虚函数重新定义。
* 纯虚函数的作用：在基类中为其派生类保留一个函数的名字，以便派生类根据需要对它进行定义。作为接口而存在 纯虚函数不具备函数的功能，一般不能直接被调用。
从基类继承来的纯虚函数，在派生类中仍是虚函数。如果一个类中至少有一个纯虚函数，那么这个类被称为抽象类（abstractclass）。
抽象类中不仅包括纯虚函数，也可包括虚函数。l抽象类必须用作派生其他类的基类，而不能用于直接创建对象实例。但仍可使用指向抽象类的指针支持运行时多态性。

# 8、什么是“引用”？申明和使用“引用”要注意哪些问题？
* 引用就是某个目标变量的“别名”(alias)，对应用的操作与对变量直接操作效果完全相同。 
* 注意问题：
```   
*   <font size="2">申明一个引用的时候，切记要对其进行初始化。</font>
```
引用声明完毕后，相当于目标变量名有两个名称，即该目标原名称和引用名，不能再把该引用名作为其他变量名的别名。<br>
声明一个引用，不是新定义了一个变量，它只表示该引用名是目标变量名的一个别名，它本身不是一种数据类型，因此引用本身不占存储单元，系统也不给引用分配存储单元。<br>
不能建立数组的引用。<br>

# 9、将“引用”作为函数参数有哪些特点？
* 传递引用给函数与传递指针的效果是一样的。这时，被调函数的形参就成为原来主调函数中的实参变量或对象的一个别名来使用，所以在被调函数中对形参变量的操作就是对其相应的目标对象（在主调函数中）的操作。
* 使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作；而使用一般变量传递函数的参数，当发生函数调用时，需要给形参分配存储单元，形参变量是实参变量的副本；如果传递的是对象，还将调用拷贝构造函数。因此，当参数传递的数据较大时，用引用比用一般变量传递参数的效率和所占空间都好。
* 使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中同样要给形参分配存储单元，且需要重复使用"*指针变量名"的形式进行运算，这很容易产生错误且程序的阅读性较差；另一方面，在主调函数的调用点处，必须用变量的地址作为实参。而引用更容易使用，更清晰。

# 10、在什么时候需要使用“常引用”？
如果既要利用引用提高程序的效率，又要保护传递给函数的数据不在函数中被改变，就应使用常引用。常引用声明方式：const类型标识符 &引用名=目标变量名；<br>
例1<br>
int;constint&=;=1;//错误=1;//正确例2<br>
foo();voidbar(&);那么下面的表达式将是非法的：<br>
bar(foo());bar("hello world");原因在于foo( )和"helloworld"串都会产生一个临时对象，而在C++中，这些临时对象都是const类型的。因此上面的表达式就是试图将一个const类型的对象转换为非const类型，这是非法的。引用型参数应该在能被定义为const的情况下，尽量定义为const 。

# 11、将“引用”作为函数返回值类型的格式的好处和需要遵守的规则?
格式：类型标识符 &函数名（形参列表及类型说明）{//函数体 }<br>
 好处：在内存中不产生被返回值的副本；（注意：正是因为这点原因，所以返回一个局部变量的引用是不可取的。因为随着该局部变量生存期的结束，相应的引用也会失效，产生runtimeerror!<br>
注意事项：
```
*   <font size="2">不能返回局部变量的引用。这条可以参照EffectiveC++[1]的Item 31。主要原因是局部变量会在函数返回后被销毁，因此被返回的引用就成为了"无所指"的引用，程序会进入未知状态。</font>
```
* 不能返回函数内部new分配的内存的引用。这条可以参照Effective C++[1]的Item 31。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成memory leak。
* 可以返回类成员的引用，但最好是const。这条原则可以参照Effective C++[1]的Item 30。主要原因是当对象的属性是与某种业务规则（business rule）相关联的时候，其赋值常常与某些其它属性或者对象的状态有关，因此有必要将赋值操作封装在一个业务规则当中。如果其它对象可以获得该属性的非常量引用（或指针），那么对该属性的单纯赋值就会破坏业务规则的完整性。
* 流操作符重载返回值申明为“引用”的作用：
流操作符<<和>>，这两个操作符常常希望被连续使用，<br>
例如： <<"hello"<<;
 ```
     *   1</pre> <font size="2">因此这两个操作符的返回值应该是一个仍然支持这两个操作符的流引用。可选的其它方案包括：返回一个流对象和返回一个流对象指针。但是对于返回一个流对象，程序必须重新（拷贝）构造一个新的流对象，也就是说，连续的两个&lt;&lt;操作符实际上是针对不同对象的！这无法让人接受。对于返回一个流指针则不能连续使用&lt;&lt;操作符。因此，返回一个流对象引用是惟一选择。这个唯一选择很关键，它说明了引用的重要性以及无可替代性，也许这就是C++语言中引入引用这个概念的原因吧。 赋值操作符=。这个操作符象流操作符一样，是可以连续使用的，
     例如：x = j= 10;或者(x=10)=100;赋值操作符的返回值必须是一个左值，以便可以被继续赋值。因此引用成了这个操作符的惟一返回值选择。
 ```
例3<br>
#include <iostream.h>int&put(int);int[10];int=-1;voidmain(){put(0)=10;//以put(0)函数值作为左值，等价于vals[0]=10;put(9)=20;//以put(9)函数值作为左值，等价于vals[9]=20;<<[0];<<[9];}int&put(int){if(>=0&&<=9)return[];else{<<"subscript error";return;}}<br>
在另外的一些操作符中，却千万不能返回引用：±*/四则运算符。它们不能返回引用，Effective C++[1]的Item23详细的讨论了这个问题。主要原因是这四个操作符没有side effect，因此，它们必须构造一个对象作为返回值，可选的方案包括：返回一个对象、返回一个局部变量的引用，返回一个new分配的对象的引用、返回一个静态对象引用。根据前面提到的引用作为返回值的三个规则，第2、3两个方案都被否决了。静态对象的引用又因为((a+b) == (c+d))会永远为true而导致错误。所以可选的只剩下返回一个对象了。

# 12、“引用”与多态的关系？
引用是除指针外另一个可以产生多态效果的手段。这意味着，一个基类的引用可以指向它的派生类实例。<br>
例4：<br>
A;B:A{...};;&=;

# 13、“引用”与指针的区别是什么？
* 指针有自己的一块空间，而引用只是一个别名；
* 使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小； + 指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象 的引用；
* 作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引 用的修改都会改变引用所指向的对象；
* 可以有const指针，但是没有const引用；
* 指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变；
* 指针可以有多级指针（**p），而引用至于一级；
* 指针和引用使用++运算符的意义不一样；
* 如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。
* 指针通过某个指针变量指向一个对象后，对它所指向的变量间接操作。程序中使用指针，程序的可读性差；而引用本身就是目标变量的别名，对引用的操作就是对目标变量的操作。此外，就是上面提到的对函数传ref和pointer的区别。

# 14、什么时候需要“引用”？
流操作符<<和>>、赋值操作符=的返回值、拷贝构造函数的参数、赋值操作符=的参数、其它情况都推荐使用引用。

# 15、结构与联合有和区别？
* 结构和联合都是由多个不同的数据类型成员组成, 但在任何同一时刻, 联合中只存放了一个被选中的成员（所有成员共用一块地址空间）, 而结构的所有成员都存在（不同成员的存放地址不同）。
* 对于联合的不同成员赋值,将会对其它成员重写, 原来成员的值就不存在了, 而对于结构的不同成员赋值是互不影响的。

# 16、关联、聚合(Aggregation)以及组合(Composition)的区别？
涉及到UML中的一些概念：关联是表示两个类的一般性联系，比如“学生”和“老师”就是一种关联关系；聚合表示has-a的关系，是一种相对松散的关系，聚合类不需要对被聚合类负责，如下图所示，用空的菱形表示聚合关系：从实现的角度讲，聚合可以表示为:<br>
classA{...}classB{*;.....}而组合表示contains-a的关系，关联性强于聚合：组合类与被组合类有相同的生命周期，组合类要对被组合类负责，采用实心的菱形表示组合关系：实现的形式是:<br>
classA{...}classB{;...}

# 17、面向对象的三个基本特征，并简单叙述之？
* 封装：将客观事物抽象成类，每个类对自身的数据和方法实行protection(private,protected,public)
* 继承：广义的继承有三种实现形式：实现继承（指使用基类的属性和方法而无需额外编码的能力）、可视继承（子窗体使用父窗体的外观和实现代码）、接口继承（仅使用属性和方法，实现滞后到子类实现）。前两种（类继承）和后一种（对象组合=>接口继承以及纯虚函数）构成了功能复用的两种方式。
* 多态：是将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。

# 18、重载（overload)和重写(overried，有的书也叫做“覆盖”）的区别？
 常考的题目。从定义上来说：   
 ```
 *   <font size="2">重载：是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。</font>
 ```
重写：是指子类重新定义父类虚函数的方法。*   从实现原理上来说：  
* 重载：编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数（至少对于编译器来说是这样的）。如，有两个同名函数：functionfunc(p:integer):integer;和functionfunc(p:string):integer;。那么编译器做过修饰后的函数名称可能是这样的：int_func、str_func。对于这两个函数的调用，在编译器间就已经确定了，是静态的。也就是说，它们的地址在编译期就绑定了（早绑定），因此，重载和多态无关！
 
重写：和多态真正相关。当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针，动态的调用属于子类的该函数，这样的函数调用在编译期间是无法确定的（调用的子类的虚函数的地址无法给出）。因此，这样的函数地址是在运行期绑定的（晚绑定）。 

# 19、多态的作用？
主要是两个：
* 隐藏实现细节，使得代码能够模块化；扩展代码模块，实现代码重用；
* 接口重用：为了类在继承和派生的时候，保证使用家族中任一类的实例的某一属性时的正确调用。

# 20、Ado与Ado.net的相同与不同？
除了“能够让应用程序处理存储于DBMS中的数据“这一基本相似点外，两者没有太多共同之处。但是Ado使用OLE DB 接口并基于微软的COM技术，而ADO.NET 拥有自己的ADO.NET 接口并且基于微软的.NET体系架构。众所周知.NET 体系不同于COM 体系，ADO.NET接口也就完全不同于ADO和OLE DB 接口，这也就是说ADO.NET和ADO是两种数据访问方式。ADO.net 提供对XML的支持。

# 21、New delete 与malloc free 的联系与区别?
都是在堆(heap)上进行动态的内存操作。用malloc函数需要指定内存分配的字节数并且不能初始化对象，new 会自动调用对象的构造函数。delete 会调用对象的destructor，而free 不会调用对象的destructor.

# 22、#define DOUBLE(x) x+x ，i = 5*DOUBLE(5)； i 是多少？
i 为30。

# 23、有哪几种情况只能用intialization list 而不能用assignment?
当类中含有const、reference成员变量；基类的构造函数都需要初始化表。

# 24、C++是不是类型安全的？
不是。两个不同类型的指针之间可以强制转换（用reinterpret cast)。C#是类型安全的。

# 25、main 函数执行以前，还会执行什么代码？
全局对象的构造函数会在main 函数之前执行。

# 26、描述内存分配方式以及它们的区别?
# 27、struct 和 class 的区别
# 28、当一个类A 中没有任何成员变量与成员函数,这时sizeof(A)的值是多少？如果不是零，请解释一下编译器为什么没有让它为零。
# 29、在8086 汇编下，逻辑地址和物理地址是怎样转换的？（Intel）
# 30、比较C++中的4种类型转换方式？
# 31、分别写出BOOL,int,float,指针类型的变量a 与“零”的比较语句。
# 32、请说出const与#define 相比，有何优点？
# 33、简述数组与指针的区别？
# 34、类成员函数的重载、覆盖和隐藏区别？
# 35、求出两个数中的较大者
# 36、如何打印出当前源文件的文件名以及源文件的当前行号？
# 37、main主函数执行完毕后，是否可能会再执行一段代码，给出说明？
# 38、如何判断一段程序是由C 编译程序还是由C++编译程序编译的？
# 39、文件中有一组整数，要求排序后输出到另一个文件中
# 40、请你详细地解释一下IP协议的定义，在哪个层上面？主要有什么作用？TCP与UDP呢 ？
# 41、请问交换机和路由器各自的实现原理是什么？分别在哪个层次上面实现的？
# 42、全局变量和局部变量有什么区别？是怎么实现的？操作系统和编译器是怎么知道的 ？
# 43、8086是多少位的系统？在数据总线上是怎么实现的？
# 44、解释局部变量、全局变量和静态变量的含义。
# 45、论述含参数的宏与函数的优缺点。
# 46、C++里面是不是所有的动作都是main()引起的？如果不是，请举例。
# 47、如何定义和实现一个类的成员函数为回调函数？
# 48、解释堆和栈的区别。
# 49、C++里面如何声明const void f(void)函数为C程序中的库函数？
# 50、内联函数在编译时是否做参数类型检查？
# 51、static有什么用途？（请至少说明两种）
# 52、引用与指针有什么区别？
# 53、描述实时系统的基本特性
# 54、全局变量和局部变量在内存中是否有区别？如果有，是什么区别？
# 55、什么是平衡二叉树？
# 56、堆栈溢出一般是由什么原因导致的？
# 57、什么函数不能声明为虚函数？
# 58、冒泡排序算法的时间复杂度是什么？
# 59、Internet采用哪种网络协议？该协议的主要层次结构？
# 60、Internet物理地址和IP地址转换采用什么协议？
# 61、IP地址的编码分为哪俩部分？
# 62、不能做switch()的参数类型是？
# 63、局部变量能否和全局变量重名？
# 64、如何引用一个已经定义过的全局变量？
# 65、全局变量可不可以定义在可被多个.C文件包含的头文件中？为什么？
# 66、语句for( ；1 ；)有什么问题？它是什么意思？
# 67、do……while和while……do有什么区别？
# 68、static 全局变量、局部变量、函数与普通全局变量、局部变量、函数区别？
# 69、-1,2,7,28,126请问28和126中间那个数是什么？为什么？
# 70、用两个栈实现一个队列的功能？要求给出算法和思路！
# 71、在c语言库函数中将一个字符转换成整型的函数是atool()吗，这个函数的原型是什么？
# 72、对于一个频繁使用的短小函数,在C语言中应用什么实现,在C++中应用什么实现?
# 73、用预处理指令#define 声明一个常数，用以表明1年中有多少秒（忽略闰年问题）
# 74、写一个“标准”宏MIN，这个宏输入两个参数并返回较小的一个。
# 75、预处理器标识#error的目的是什么？
# 76、嵌入式系统中经常要用到无限循环，你怎么样用C编写死循环呢？
# 77、关键字static的作用是什么？
# 78、关键字const是什么含意？
# 79、关键字volatile有什么含意 并给出三个不同的例子。
# 80、ASDL使用的是什么协议？并进行简单描述？
# 81、什么是预编译,何时需要预编译?
# 82、Itearator各指针的区别
# 83、C++中的class和struct的区别
# 84、关系模型的基本概念
# 85、C语言中结构化程序设计的三种基本控制结构
# 86、三种基本的数据模型
# 87、设计模式：工厂模式 和 单例模式 介绍一下？
# 88、const的作用有哪些，谈一谈你对const的理解？
# 89、描述char*、const char*、char* const、const char* const的区别？
# 90、指针常量和常量指针有什么区别？
# 91、static的作用是什么，什么情况下用到static？
# 92、全局变量与局部变量的区别？
# 93、宏定义的作用是什么？
# 94、内存对齐的概念？为什么会有内存对齐？
# 95、inline 内联函数的特点有哪些？它的优缺点是什么？
# 96、如何避免野指针？
# 97、如何计算结构体长度？
# 98、sizeof和strlen有什么区别？
# 99、知道条件变量吗？条件变量为什么要和锁配合使用？
# 100、如何用C 实现 C++ 的面向对象特性（封装、继承、多态）
# 101、memcpy怎么实现让它效率更高？
# 102、typedef和define有什么区别？
# 103、extern有什么作用，extern C有什么作用？
