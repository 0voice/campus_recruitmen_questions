# 题目
蛐蛐国最近蚯蚓成灾了！

隔壁跳蚤国的跳蚤也拿蚯蚓们没办法，蛐蛐国王只好去请神刀手来帮他们消灭蚯蚓。

蛐蛐国里现在共有 n 只蚯蚓，第 i 只蚯蚓的长度为 a<sub>i</sub> ，所有蚯蚓的长度都是非负整数，即可能存在长度为 0 的蚯蚓。

每一秒，神刀手会在所有的蚯蚓中，准确地找到最长的那一只，将其切成两段。

若有多只最长的，则任选一只。

神刀手切开蚯蚓的位置由有理数 p 决定。

一只长度为 x 的蚯蚓会被切成两只长度分别为 ⌊px⌋ 和 x−⌊px⌋ 的蚯蚓。

特殊地，如果这两个数的其中一个等于 0，则这个长度为 0 的蚯蚓也会被保留。

此外，除了刚刚产生的两只新蚯蚓，其余蚯蚓的长度都会增加一个非负整数 q。

蛐蛐国王知道这样不是长久之计，因为蚯蚓不仅会越来越多，还会越来越长。

蛐蛐国王决定求助于一位有着洪荒之力的神秘人物，但是救兵还需要 m 秒才能到来。

蛐蛐国王希望知道这 m 秒内的战况。

具体来说，他希望知道：

m 秒内，每一秒被切断的蚯蚓被切断前的长度，共有 m 个数。
m 秒后，所有蚯蚓的长度，共有 n+m 个数。
输入格式
第一行包含六个整数 n,m,q,u,v,t，其中：n,m,q 的意义参考题目描述；u,v,t 均为正整数；你需要自己计算 p=u/v（保证 0<u<v）；t 是输出参数，其含义将会在输出格式中解释。

第二行包含 n 个非负整数，为 a<sub>1</sub>,a<sub>2</sub>,…,a<sub>n</sub>，即初始时 n 只蚯蚓的长度。

同一行中相邻的两个数之间，恰好用一个空格隔开。

输出格式
第一行输出 ⌊m/t⌋ 个整数，按时间顺序，依次输出第 t 秒，第 2t 秒，第 3t 秒，……被切断蚯蚓（在被切断前）的长度。

第二行输出 ⌊(n+m)/t⌋ 个整数，输出 m 秒后蚯蚓的长度；需要按从大到小的顺序，依次输出排名第 t，第 2t，第 3t，……的长度。

同一行中相邻的两个数之间，恰好用一个空格隔开。

即使某一行没有任何数需要输出，你也应输出一个空行。

请阅读样例来更好地理解这个格式。

数据范围<br>
1≤n≤10<sup>5</sup>,<br>
0≤a<sub>i</sub>≤10<sup>8</sup>,<br>
0<p<1,<br>
0≤q≤200,<br>
0≤m≤7∗10<sup>6</sup>,<br>
0<u<v≤10<sup>9</sup>,<br>
1≤t≤71<br>

输入样例：
```
3 7 1 1 3 1
3 3 2
```
输出样例：
```
3 4 4 4 5 5 6
6 6 6 5 5 4 4 3 2 2
```
样例解释<br>
样例中，在神刀手到来前：3 只蚯蚓的长度为 3,3,2。

1 秒后：一只长度为 3 的蚯蚓被切成了两只长度分别为 1 和 2 的蚯蚓，其余蚯蚓的长度增加了 1。最终 4 只蚯蚓的长度分别为 (1,2),4,3。 括号表示这个位置刚刚有一只蚯蚓被切断。

2 秒后：一只长度为 4 的蚯蚓被切成了 1 和 3。5 只蚯蚓的长度分别为：2,3,(1,3),4。

3 秒后：一只长度为 4 的蚯蚓被切断。6 只蚯蚓的长度分别为：3,4,2,4,(1,3)。

4 秒后：一只长度为 4 的蚯蚓被切断。7 只蚯蚓的长度分别为：4,(1,3),3,5,2,4。

5 秒后：一只长度为 5 的蚯蚓被切断。8 只蚯蚓的长度分别为：5,2,4,4,(1,4),3,5。

6 秒后：一只长度为 5 的蚯蚓被切断。9 只蚯蚓的长度分别为：(1,4),3,5,5,2,5,4,6。

7 秒后：一只长度为 6 的蚯蚓被切断。10 只蚯蚓的长度分别为：2,5,4,6,6,3,6,5,(2,4)。

所以，7 秒内被切断的蚯蚓的长度依次为 3,4,4,4,5,5,6。

7 秒后，所有蚯蚓长度从大到小排序为 6,6,6,5,5,4,4,3,2,2。
# 参考答案
```c++
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define p u/v
#define fir(i,a,b) for(ll i=a;i<=b;i++)
const int N=1e7+10;
queue<ll> p1,p2,p3;
ll n,m,q,u,v,t,a[N],data;
int cmp(int a,int b)
{
    return a>b;
}
int calc(ll t)
{
    ll x=-1,a=-1,b=-1,c=-1;
    if (!p1.empty())
        a=p1.front()+t*q;
    if (!p2.empty())
        b=p2.front()+t*q;
    if (!p3.empty())
        c=p3.front()+t*q;
    x=max(a,max(b,c));
    if (x==a)
        p1.pop();
    else
    if (x==b)
        p2.pop();
    else
    if (x==c)
        p3.pop();
    return x;
}
int main()
{
    ios::sync_with_stdio(false);
    cin>>n>>m>>q>>u>>v>>t;
    fir(i,1,n)
        cin>>a[i];
    sort(a+1,a+1+n,cmp);
    fir(i,1,n)
        p1.push(a[i]);
    fir(i,1,m)
    {
        ll x=calc(i-1);
        if (!(i%t))
            cout<<x<<" ";
        ll now1=x*p;
        ll now2=x-now1;
        p2.push(now1-i*q);
        p3.push(now2-i*q);
    }
    cout<<endl;
    fir(i,1,(n+m))
    {
        ll x=calc(m);
        if (i%t==0)
            cout<<x<<" ";
    }
    return 0;
}
