# 题目
达达是一名漫画家，她有一个奇特的爱好，就是在纸上画括号。

这一天，刚刚起床的达达画了一排括号序列，其中包含小括号 ( )、中括号 [ ] 和大括号 { }，总长度为 N。

这排随意绘制的括号序列显得杂乱无章，于是达达定义了什么样的括号序列是美观的：

空的括号序列是美观的；<br>
若括号序列 A 是美观的，则括号序列 (A)、[A]、{A} 也是美观的；<br>
若括号序列 A、B 都是美观的，则括号序列 AB 也是美观的。<br>
例如 [(){}]() 是美观的括号序列，而)({)[}]( 则不是。<br>

现在达达想在她绘制的括号序列中，找出其中连续的一段，满足这段子序列是美观的，并且长度尽量大。

你能帮帮她吗？

输入格式<br>
输入一行由括号组成的字符串。

输出格式<br>
输出一个整数，表示最长的美观的子段的长度。

数据范围<br>
字符串长度不超过 10<sup>5</sup>。

输入样例：
```
({({(({()}})}{())})})[){{{([)()((()]]}])[{)]}{[}{)
```
输出样例：
```
4
```
# 参考答案
```c++
#include <iostream>
#include <cstring>
typedef long long ll;
using namespace std;
const int N = 1e5+7;
int n,ans,f[N];
char s[N];

int main() {
    scanf("%s",s+1); n = strlen(s+1);
    f[1] = 0;
    for(int i = 2;i <= n; ++i) {
        if(s[i] == '(' || s[i] == '[' || s[i] == '{') continue;
        if((s[i-1-f[i-1]] == '(' && s[i] == ')') || (s[i-1-f[i-1]] == '[' && s[i] == ']') || (s[i-1-f[i-1]] == '{' && s[i] == '}')) {
            f[i] = f[i-1]+2+(i-2-f[i-1]? f[i-2-f[i-1]]:0);
            ans = max(ans,f[i]);
        }
    }
    cout << ans;
    return 0;
}
