# 题目
有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。

第 i 件物品的体积是 v<sub>i</sub>，价值是 w<sub>i</sub>。

求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。

输出 最优选法的方案数。注意答案可能很大，请输出答案模 10<sup>9</sup>+7 的结果。

输入格式

第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。

接下来有 N 行，每行两个整数 v<sub>i</sub>,w<sub>i</sub>，用空格隔开，分别表示第 i 件物品的体积和价值。

输出格式

输出一个整数，表示 方案数 模 10<sup>9</sup>+7 的结果。

数据范围
0<N,V≤1000
0<v<sub>i</sub>,w<sub>i</sub>≤1000
输入样例
```
4 5
1 2
2 4
3 4
4 6
```
输出样例：
```
2
```
# 参考答案
```c++
#include<iostream>

using namespace std;

const int N = 1010;
const int mod = 1e9 + 7;

int f[N], cnt[N];
int main()
{
    int n, m;
    scanf("%d%d", &n, &m);
    for(int i = 0; i <= m; i ++)  cnt[i] = 1;

    for(int i = 1; i <= n; i ++)
    {
        int v, w;
        scanf("%d%d", &v, &w);
        for(int j = m; j >= v; j --)
        {
            int value = f[j - v] + w;
            if(value > f[j])
            {
                f[j] = value;
                cnt[j] = cnt[j - v];
            }else if(value == f[j]){
                cnt[j] = (cnt[j] + cnt[j - v]) % mod;
            }
        }
    }

    printf("%d", cnt[m]);
    return 0;
}




