# 题目
25 盏灯排成一个 5×5 的方形。

每一个灯都有一个开关，游戏者可以改变它的状态。

每一步，游戏者可以改变某一个灯的状态。

游戏者改变一个灯的状态会产生连锁反应：和这个灯上下左右相邻的灯也要相应地改变其状态。

我们用数字 1 表示一盏开着的灯，用数字 0 表示关着的灯。

下面这种状态
```
10111
01101
10111
10000
11011
```
在改变了最左上角的灯的状态后将变成：
```
01111
11101
10111
10000
11011
```
再改变它正中间的灯后状态将变成：
```
01111
11001
11001
10100
11011
```
给定一些游戏的初始状态，编写程序判断游戏者是否可能在 6 步以内使所有的灯都变亮。

输入格式<br>
第一行输入正整数 n，代表数据中共有 n 个待解决的游戏初始状态。

以下若干行数据分为 n 组，每组数据有 5 行，每行 5 个字符。

每组数据描述了一个游戏的初始状态。

各组数据间用一个空行分隔。

输出格式<br>
一共输出 n 行数据，每行有一个小于等于 6 的整数，它表示对于输入数据中对应的游戏状态最少需要几步才能使所有灯变亮。

对于某一个游戏初始状态，若 6 步以内无法使所有灯变亮，则输出 −1。

数据范围<br>
0<n≤500

输入样例：
```
3
00111
01011
10001
11010
11100

11101
11101
11110
11111
11111

01111
11111
11111
11111
11111
```
输出样例：
```
3
2
-1
```
# 参考答案
```c++
// 思路：我们枚举第一行的点击方法，共32种，完成第一行的点击后，固定第一行，
// 从第一行开始递推，若达到第n行不全为0，说明这种点击方式不合法。
// 在所有合法的点击方式中取点击次数最少的就是答案。
// 对第一行的32次枚举涵盖了该问题的整个状态空间，因此该做法是正确的
// 
// 时间复杂度：32*20*5*500
// 对第一行操作有32种可能 * 对前四行有20种操作可能 * 每一次操作都要改变5个灯的状态 * 最多读入的时候可能有500次light矩阵
//
// 最关键的两个性质
// 每一个位置最多只会被点击一次
// 如果固定了第一行，那么满足题意的点击方案最多只有一种
#include <iostream>
#include <vector>
#include <cstring>
#include <limits.h>

//定义全局变量时，需要赋值的时候要慎重考虑
using namespace std;
char light[10][10];

void turn(int x, int y) {
    int dx[5] = {0, -1, 1, 0, 0}, dy[5] = {0, 0, 0, -1, 1};
    for (int i = 0; i < 5; i ++ ) {
        int a = x + dx[i], b = y + dy[i];
        if (a >= 0 && a < 5 && b >= 0 && b < 5) {
            light[a][b] ^= 1;
        }
    }
}

int work() {  //无参数

    int res = INT_MAX; //不能定义为全局变量，每运行一次work，就要重新设置res为最大变量
    //遍历32个第一行的操作可能
    for (int k = 0; k < 1 << 5; k ++ ) {

        int cnt = 0; //不能定义为全局变量，每次新的第一行状态，都要重新开始计算cnt
        char backup[10][10];
        memcpy(backup, light, sizeof light); //备份，因为下面的操作会改变light


        //第一行按灯一共有32种可能，对于每一种可能，我们操作选择后，开始固定，
        //此时第一行不一定是全亮的状态，第一行只是32种操作可能的一种
        //然后遍历前四行，如果light[i][j] == '0', 那么turn(i+1, j)


        //这一步是枚举第一行的点击方法，只要第一行固定了，那么满足题意的点击方法就只有一种了。
        //假如第一行是10101, k从0到31进行枚举，如果k = 11000，
        //那么代表light矩阵中第一行的第一个和第二个灯要点击一下，
        //第一行变为01101，
        //之后固定这一行，改变下面的灯看是否能全变亮。
        //这也就是为什么我们copy light, 每一次对k的枚举都会改变light。
        for (int i = 0; i < 5; i ++ ) 
            if (k >> i & 1) {
                turn(0, i); //这里面已经改变了light[0][i]
                cnt ++ ;
            }

        for (int i = 0; i< 4; i ++ )
            for (int j = 0; j < 5; j ++ ) {
                if (light[i][j] == '0') { //如果前一行 == ‘0’，那么改变下一行
                    turn(i+1, j);
                    cnt ++ ;
                }
            }

        //用一个bool来表示最后一行的状态，是全亮的话bool就为true
        bool is_successful = true;
        for (int i = 0; i < 5; i ++ ) {
            if (light[4][i] == '0') {
                is_successful = false;
                break;
            }
        }

        //对于32种第一行的操作后，每一次或许可以让light的灯都变亮, 或许不可以
        //每一次，我们都记录一下操作次数cnt，更新res，直到res是最小的操作数
        if (is_successful == true) res = min(res, cnt); 

        memcpy(light, backup, sizeof light); //备份，使light变为最开始第一行未操作的状态
    }

    if (res <= 6) return res;
    else return -1;
}


int main() {
    int n;
    cin >> n;
    //读入
    while (n -- ) {
        for (int i = 0; i < 5; i ++ )
            for (int j = 0; j < 5; j ++ ) 
                cin >> light[i][j];
        cout << work() << endl;
    }
    return 0;
}
